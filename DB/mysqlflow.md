





# Mysql 구조 및 동작 흐름

MySQL 구조 및 동작 흐름을 알기 전에 먼저 DBMS에 대해 이해 해보자

## DBMS











## MySQL

![image](https://github.com/russell-seo/TIL/assets/79154652/af154f4b-5661-4d8f-aeb2-2df3bd5dd823)



Mysql 서버는 크게 Mysql 엔진과 스토리지 엔진으로 나눌 수 있다.

Mysql 엔진의 경우 클라이언트로 부터 접속하고 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서, 옵티마이저로 이루어져 있다.

쿼리 관련 처리는 이곳에서 하기 때문에 거의 `두뇌`와 같은 역할을 하면 된다고 생각하자.

스토리지 엔진의 경우 데이터를 `실제 디스크에 저장하거나, 혹은 디스크에 저장된 데이터를 읽어오는 작업을 하며` 하나의 MySQL 서버는 여러 개의 스토리지 엔진을 사용 할 수 있다.

MySQL 엔진과 스토리지 엔진은 서로 `Handler API`라는 것을 사용하여 데이터를 주고 받는다.



## Mysql Thread

![image](https://github.com/russell-seo/TIL/assets/79154652/8da3b87a-9aef-4a2c-9879-43d8d230df05)

Mysql 서버는 기본적으로 스레드 기반으로 동작하며, ForeGround / BackGround 스레드로 나누어져 있다.

### ForeGround Thread

- 최소 MySQL 에 접속된 클라이언트 수 만큼 존재하며, 클라이언트가 요청하는 쿼리문을 수행한다.
- 데이터를 MySQL의 데이터 버퍼나 캐시로 부터 가져오고, 없으면 직접 디스크에 있는 데이터를 가져오거나 인덱스 파일로 부터 파일을 읽어온다.
- 이때 MysISAM 같은 스토리지 엔진은 디스크 쓰기 작업까지 foreGround 가 하지만, InnoDB의 경우 데이터 버퍼 / 캐시 까지만 관리하고 디스크 쓰기는 BackGround 가 처리한다.

- 실행 후 커넥션 종료 시 해당 스레드는 캐시로 돌아가는데, 만약 스레드 캐시에 이미 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 자체 스레드 캐시에 존재하는 스레드 수를 관리하는 역할 도 한다.

- 보통 스레드 수는 thread_cache_size 라는 시스템 변수로 컨트롤이 가능하다.


### BackGround Thread

InnoDB 스토리지 엔진의 경우 백그라운드 스레드가 정말 여러가지 일을 처리한다.

1. 인서트 버퍼(Insert Buffer) 병합
2. 디스크에 로그 기록(Log Thread)
3. 버퍼 풀(Buffer Pool)의 데이터를 디스크에 기록(Write Thread)
4. 데이터를 버퍼로 읽어오기
5. 잠금, 데드락 모니터링

- log / write Thread의 경우 Innodb_write_io_threads, Innodb_read_to_threads 시스템 변수로 스레드 개수를 제어할 수 있다. 쓰기 쓰레드의 경우 2~4개 별도의 스토리지 사용 시 디스크를 최적으로 사용할 만큼 설정하는 것이 좋다.

- 추가로 데이터 쓰기 작업은 지연이 가능하지만 읽기 작업은 지연 처리가 안 되기 때문에 보통 DBMS에서 쓰기 작업은 버퍼링을 통해 일괄 처리하는 기능이 존재한다.
- 덕분에 CUD 쿼리 작성 시 디스크에 반영될 때 까지 완전히 기다릴 필요가 없다. 하지만 MyISAM 에서는 foreGround Thread가 쓰기 작업 까지 하다 보니 쓰기 버퍼링 기능을 사용할 수 없다.


### MySQL Memory Allocation

![image](https://github.com/russell-seo/TIL/assets/79154652/03cdea2f-f73e-4a5e-a1f5-50f56a85f4c2)

MySQL 에서 사용하는 메모리 공간은 크게 `글로벌 메모리 영역` `세션 메모리 영역` 으로 구분된다.

`글로벌 메모리 영역`의 경우 MySQL 서버가 시작되면서 OS로 부터 할당되며, OS마다 조금씩 정책이 다르다. 글로벌 메모리 영역은 단 하나의 메모리 공간만 할당 받으며, 모든 스레드 에게 공유 된다.

`세션 메모리 영역`의 경우 스레드당 하나씩 생성되며, 공유되지 않고 사용된다.
쿼리의 용도 별로 공간이 할당되고, 필요하지 않으면 아예 메모리 공간 자체가 생성되지 않을 수 있기 때문에(정렬, 조인 버퍼) 주의해야 한다.


### MySQL 쿼리 실행 과정

`SQL Parser -> SQL 옵티마이저 -> SQL 실행기 -> 데이터의 읽기/쓰기 작업 -> 디스크`

MySQL 에서는 MySQL 엔진에 의해 SQL 실행기 까지 실행되고, 마지막으로 디스크에 데이터를 읽거나 쓰는 작업은 스토리지 엔진이 처리한다.

어떤식으로 디스크에 데이터를 읽고 쓰는지가 스토리지 엔진별로 갈린다. 이때 데이터를 읽고 쓰는 작업은 대부분 1건의 레코드 단위로 처리된다.

이때 MySQL 엔진은 스토리지 엔진을 조정하기 위해 `Handler` 라는 것을 사용한다.


### MySQL Query Execution

![image](https://github.com/russell-seo/TIL/assets/79154652/7de039a5-ec62-47a9-bc97-aaea3807ccf0)

- `Query Parser`
  - 사용자 요청으로 들어온 `쿼리 문장을 Token 으로 분리하여 트리 형태의 구조로 만들어` 내는 작업을 의미한다.
  - 쿼리 문장의 기본적인 문법 오류는 이 단계에서 발생하며, 이 경우 오류 메시지가 사용자에게 나가게 된다.
 
- `전처리기`
  - 파서를 통해 나온 `트리를 바탕으로 쿼리 문장에 구조적인 문제` 가 있는지 확인한다.
  - 테이블 이름이나 컬럼 이름, 내장 함수 존재여부, 객체의 접근 권한등을 여기에서 확인
 
- `옵티마이저`
  - 쿼리 문장을 `가장 저렴한 비용으로 처리하기 위한 최적화`를 진행한다. 매우 중요


- `실행 엔진`
  - 핸들러에게 요청해서 `받은 결과를 사용자나 또 다른 핸들러의 요청에 대한 입력으로 연결`하는 역할을 수행한다.
  - 핸들러는 실제로 일을 처리하는 역할을 수행하고, 실행 엔진이 옵티마이저와 실행기 사이에서 연결하는 역할을 한다.
    
  > Group By 처리 과정
  > 실행 엔진이 핸들러에게 임시 테이블 생성 요청
  > 실행 엔진은 where 절에 대한 레코드를 읽으라고 핸들러에게 요청
  > 읽어온 테이블을 임시 테이블에게 저장하라고 핸들러에게 요청
  > 생성된 임시테이블에 대해 필요한 방식으로 데이터를 읽어오라고 핸들러에게 요청
  > 최종 결과를 실행 엔진이 사용자나 다른 핸들러에게 넘긴다.
  
- `핸들러(스토리지 엔진)`
  - 실행 엔진의 요청에 따라서 `데이터를 디스크로 저장하거나 디스크로부터 읽어오는 역할`을 진행한다.
  - 어떤 스토리지 엔진을 가진 테이블을 처리하는지에 따라서 InnoDB 엔진을 사용할지, MyISAM 엔진을 사용할지 채택하게 된다.
 
- `쿼리 캐시`
  - 그림에는 없지만, MySQL 쿼리 캐시는 `SQL 실행 결과를 메모리에 캐시하고` 동일한 쿼리가 실행되면 테이블을 읽는 대신에 메모리에 저장된 결과를 바로 반환하는 역할을 한다.
  - 하지만 테이블의 데이터가 변경되면 캐시도 함께 갱신되어야 하기 때문에 변경된 테이블에 관련된 내용은 전부 삭제 했어야 한다. 8.0부터는 쿼리 캐시 기능 자체가 제거됬다.
 

--
https://cl8d.tistory.com/100
https://seastar105.tistory.com/139
--
