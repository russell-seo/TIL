# DMA 부터 CPU, Process 까지

  - [DMA를 알면 고성능 소켓이 보인다](#dma를-알면-고성능-소켓이-보인다)
  - [CPU도 당신처럼 예측하고 미리 움직인다](#cpu도-당신처럼-예측하고-미리-움직인다)
  - [CPU가 예측해서 발생한 심각한 문제](#cpu가-예측해서-발생한-심각한-문제)
  - [프로세스와 스레드](#프로세스와-스레드)
  - [프로세스 상태(휴식, 보류)와 문맥 교환](#프로세스-상태와-문맥-교환)
  - [CPU 스케줄링](CPU-스케줄링)
  - [Process 간 통신](process-간-통신)



# DMA를 알면 고성능 소켓이 보인다

## DMA(Direct Memory Access)

![스크린샷 2023-04-19 오전 12 10 35](https://user-images.githubusercontent.com/79154652/232821558-f9d2ee5e-9016-4d0b-b90f-e3618164d80e.png)

### DMA를 지원 안할 시

1. 네트워크에 송신할 데이터를 위에 보이는 빨간색 1번 버퍼에 적재한다.
2. File 에다가 Write 한다. Socket 이면 Send -> I/O Buffer에 복사가 된다.
3. 커널 계층으로 내려가면서 Data 가 Segment화 된다.
4. 커널에 존재하는 버퍼에 복사한다.
5. NIC에 보낸다.
6. 네트워크로 나간다.

- 1,2,3 번 모두 RAM 메모리 이다.

### DMA를 지원할 시

1. 프로세스가 메모리를 확보해놓고 recv를 대기한다.
2. 위 그림의 왼쪽에 있는 2,3을 스킵하고 바로 NIC에 들어온 데이터를 Process의 메모리에 적재한다.


# CPU도 당신처럼 예측하고 미리 움직인다

CPU : 연산장치 -> 속도가 중요하다

연산은 Core가 한다. 연산할 데이터들은 RAM에 존재한다.

CPU와 RAM 사이에 완충 역할은 하는 것이 `Cache` 이다.

- Cache 3개 종류가 있다.

L1, L2 Cache 는 CPU와 붙어있다.(제조사 마다 다름)

L3는 코어가 같이 쓴다.

소위 예측은 Cache 에서 일어난다. CPU가 미리 예측해서 RAM에서 `Cache` 메모리로 미리 가져온다.


CPU -> 연산
RAM -> 데이터(자료를 다루어줌)


GPU -> 다수의 코어, 용도가 다르다, AI 연산에 자주 사용됨
PIM -> Process In Memory 메모리에서 연산을 한다.

# CPU가 예측해서 발생한 심각한 문제

가상화된 VM에서 CPU연산은 진짜 CPU에서 처리한다. 즉 2개의 가상머신중 하나가 읽어온 Cache 데이터를 다른 VM에서도 읽을 수 있다.

[참조](https://parksb.github.io/article/31.html)

# 프로세스와 스레드

컴퓨터에서 자원은 크게 `CPU`, `RAM` 나뉜다.

`RAM`, `HDD`를 합쳐서 Virtual Memory 라고 한다. 프로세스 단위로 `Virtual Memory` 가 주어진다. 

기본적으로 자원을 Process 에게 준다. 윈도우 같은 경우에는 스레드 기준으로 CPU를 준다.

OS 입장에서 프로세스를 관리하기 위해 필요한 장치를 `PCB`가 있다. 쓰레드는 `TCB`

- CPU는 프로세스를 줄을 세워서 분할해서 사용한다.(시분할 사용)

- OS가 프로세스를 관리할때 Queue가 쓰인다. 몇천개의 프로세스를 큐에 넣고 첫번째 부터 디스패치 해서 연산. 코어 개수만큼씩 꺼낸다.

# 프로세스 상태와 문맥 교환

![image](https://user-images.githubusercontent.com/79154652/233117316-19767dd3-c541-4587-ab9a-b2fb8e7faa44.png)


- Sleep, Suspend 두 상태가 존재한다.

- Suspend 는 외부 요인(OS, 다른 프로세스)
  - 의도되지 않은 것이다.
 
- Sleep은 자발적이다.

- Ready-Queue 에서 어떤 스케줄링 되고 있는 프로세스가 Sleep or Suspend를 하면 대기열에서 이탈한다.
- Sleep(10ms)를 하면 10ms + & 만큼 쉬는데 이 & 가 대기열에서 이탈했다가 다시 대기열로 재진입한다. 그래서 대기열 앞에있는 프로세스가 다 처리되어야 다시 진입한 프로세스가 연산한다. 이것이 & 이다.
- Suspend 도 Sleep과 동일하다.

![스크린샷 2023-04-20 오전 12 10 43](https://user-images.githubusercontent.com/79154652/233120092-4fdee5ed-71ba-470d-a938-ed771126002e.png)

- CPU는 연산하면서 상태가 계속 변화 한다. 이러한 상태 데이터는 모두 Register에 저장되어 있다.

# Process의 생성과 복사

- Process 에 가상메모리가 할당된다. 가상메모리는 독립적인 공간이며 Process에 속한 Threads들이 접근 할 수 있다.
- 새로운 프로세스가 생성될 때 가상메모리 공간이 있어야 한다.


# CPU 스케줄링

스케줄링은 Process 를 줄세우는 것인데, OS가 CPU 같은 핵심자원들을 Thread 들이 `선점`한다.


![스크린샷 2023-04-25 오전 12 31 27](https://user-images.githubusercontent.com/79154652/234044617-7373ee4e-b7f2-4f2a-a72d-7869a99f08e4.png)

- 고수준 스케줄링
  - Job 이라고 한다.
- 저수준 스케줄링
  - 프로세스, 쓰레드 단위로 CPU를 선점해서 작동하는 것이 일반적이다.
  - 선점형 스케줄링이 일반적이다.

- 스케줄링 시 고려사항
  - 선점형 스케줄링
    - 프로세스가 CPU 자원을 선점해서 쓰려고 하는데 이것을 OS가 통제할 수 있는 상황   
  - 비선점형 스케줄링
    - 어떤 프로세스 CPU 자원을 선점해서 쓰면 프로세스가 끝날 때 까지 다른 프레세스는 Wait 인 상태이다.

- 우선순위
  - 서버는 백그라운드


# Process 간 통신

Process 공간이 독립적이다. 외부 접근차단을 OS가 보장한다.

Memory -> 크기 고정
File -> Stream 시작 -> 끝(?)은 없다 

![image](https://user-images.githubusercontent.com/79154652/234307413-f3ccacc4-8886-4435-af0b-ec6e7c1b24ba.png)

- RPC
  - 일반적으로 프로세스는 자신의 독립적인 공간에 있는 함수만 호출가능하다 
  - 하지만 RPC는 자신과 다른 주소공간에 있는 프로세스의 함수를 호출할 수 있게 하는 것.


- Data seg pragma
  - DLL 전역변수 설정하여 exe 에서 같이 참조하여 사용한다.

# 공유자원과 임계구역

메모리, File

- 임계 구간
  - 무조건 최소화 해야한다.
  
# 물리 메모리 관리

  - 1차 메모리
    - RAM
  - 2차 메모리
    - SSD, HDD

- 1Byte 메모리 마다 주소가 붙는다.
  - 32Bit 시스템 -> 2^32(42.9억) 만큼의 메모리를 관리할 수 있다.
  - 4GB가 최대 관리할수 있는 메모리
  - 만약 RAM 을 8GB 컴퓨터를 샀는데 32Bit OS를 설치하면 4GB 밖에 관리하지못하고 나머지 4GB는 못쓴다.
- 1Byte 는 기억 공간의 최소단위 이다.


- CPU 64Bit, OS 64Bit -> 64Bit PlatForm 이라고 부른다.

- 메모리 관리자
  - 배치 정책
    - RAM 에 일정영역을 나누어 쓰다가 꽉차면 재 배치를 한다.
    - 단위 -> 메모리를 같은 크기로 자르는 것을 Page(4KB) 라고한다.
    - Segmentation -> 프로세스를 크기에 맞게 자르는 것
    - Segment -> Stack, Heap 등을 나누는 것

# 절대주소와 상대주소

- 메모리 단위 : 1Byte -> 주소가 붙는다. 64Bit 32Bit -> Application Process 주소와 RAM에 부여되는 주소가 다르다.

![스크린샷 2023-05-03 오전 12 33 13](https://user-images.githubusercontent.com/79154652/235713999-4b3095a5-bd27-4017-8d80-dd42265595f4.png)

- 절대주소 : 운영체제 영역의 0에서 부터 메모리 주소까지 측정했을 때
- 상대주소 : 운영체제 영역을 제외한 사용자 영역으로 부터 메모리 주소 까지 측정 했을 때
  - 논리주소 공간이다 = Virtual

# 메모리 오버레이와 스왑

- 메모리 오버레이
  - 프로그램의 크기가 실제 물리 메모리 크기 보다 클 때 전체 프로그램을 가져오는 대신 `적당한 크기로 잘라서` 가져오는 것


- 스왑(Swap)
  - HDD에 스왑 영역을 둔다.
  - RAM + 스왑 영역을 합쳐서 실제 컴퓨터가 쓸 수 있는 메모리 공간
  - RAM 에서 HDD 로 나가는 것을 스왑 OUT ( 잘 안쓰는 것들 )
  - HDD 에서 RAM 으로 보내면 스왑 IN ( CPU에서 빠르게 접근해야 하는 것들 )
  - Swap In/Out -> Page In/Out 이라고 하기도 한다.
  - 현재는 SSD를 사용하면서 HDD 보다 몇 배나 빨라졌다. 특히 I/O 작업이 빨라 졌기 때문에 체감상 더 빠르게 느껴진다.
  - 보통 느리다고 표현하는 것들의 대부분은 I/O 작업이 Wait 걸리기 때문이다.
