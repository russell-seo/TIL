# 의존성 역전하기

  1. 단일 책임 원칙
      
      - 이 원칙의 일반적인 해석은 아래와 같다.
        
        `하나의 컴포넌트는 오로지 한 가지 일만 해야하고, 그것을 올바르게 수행해야 한다.`
        
      - 그러나 단일 책임 원칙의 실제 정의는 아래와 같다.

        `컴포넌트를 변경하는 이뉴는 오직 하나뿐 이어야 한다.`
  
      - 책임은 한가지 일만 하는 것 보다는 `변경할 이유` 로 해석해야 한다.
      - 즉 하나의 컴포넌트가 의존하는 것이 전혀 없다고 하면 이 컴포넌트의 변경할 유일한 이뉴는 새로운 요구사항에 의해 기능을 바꿔야할 때 뿐이다.
      - 그러나 만약 의존되어 있는 컴포넌트들의 경우 다른 컴포넌트가 바뀌게 된다면 같이 바뀌게 된다.
 
 2. 의존성 역전 원칙
    
    - 이 원칙의 해석은 아래와 같다.

      `코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.`
      
   - 엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 엔티티를 도메인 계층으로 올린다.
   - 그러나 이제는 영속성 계층의 리포지토리가 도메인 계층에 있는 엔티티에 의존하기 때문에 두 계층 사이에 순환 의존성이 생긴다.
   - 이 부분이 바로 DIP를 적용하는 부분이다.
   - 도메인 계층에 리포지토리에 대한 인터페이스를 만들고, 실제 리포지토리는 영속성 계층에서 구현하게 하는 것이다.
   
   ![image](https://user-images.githubusercontent.com/79154652/179998980-973efe7d-3b12-4940-b447-8f9d73113c22.png)

   이러한 묘수로 영속성 코드에 있는 의존성으로 부터 도메인 로직을 해방 시켰다. 이것이 다음 절에서 살펴볼 두가지 아키텍처 스타일의 핵심이다.


## 클린 아키텍처

  ![image](https://user-images.githubusercontent.com/79154652/180002222-c9048355-ee09-49f2-8f7c-a2397a88aebc.png)
  
  위의 아키텍처에서 계층들은 동심원으로 둘러싸여 있다. 이 아키텍처에서 가장 중요한 규칙은 의존성 규칙으로, 계층 간의 모든 의존성이 안쪽으로 향해야 한다는 것이다.
  
  - 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질수 없고 비즈니스 규칙에 집중할 수 있다.
  - 예를 들어 DDD 도메인 주도 설계를 가장 순수한 형태로 적용해 볼 수도 있다.
  - 가령 영속성 계층에서 ORM 프레임워크를 사용한다고 해보자. 일반적으로 ORM 프레임워크는 데이터베이스 구조 및 객체 필드와 데이터베이스 칼럼의 매핑을 서술한 메타데이터를 담고 있는 엔티티 클래스를 필요로 한다.
  - 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어야 한다.
  - 즉 `도메인 계층과 영속성 계층이 데이터를 주고 받을 때, 두 엔티티를 서로 변환해야 한다는 뜻이다.`

## 육각형 아키텍처(핵사고날 아키텍처)

![image](https://user-images.githubusercontent.com/79154652/180003680-b1ceadfa-a226-45d6-b332-742a33f7fde7.png)

- DIP

  - SOLID 원칙중 DIP(의존성 역전 원칙)은 객체간 의존관계를 맺을때 상위 추상화에 의존해야 한다.

  ![image](https://user-images.githubusercontent.com/79154652/180109411-9e9d37cc-c728-4a3b-b950-0e7e434301c6.png)
  
  위의 그림처럼 상위 계층은 하위 계층을 의존하는 구조의 가장 큰 단점은 의존하는 하위 계층에 변경이 있을 경우 상위계층이 영향을 받는다는 점
  
  ![image](https://user-images.githubusercontent.com/79154652/180109499-aa2638a2-57f7-4a4e-a956-f3d4e50ae5f3.png)
  
  하위 계층 객체의 구현과 인터페이스를 분리해 인터페이스를 상위계층으로 올려놓으면, 의존관계가 1차적으로 `하방`에서 `수평`으로 바뀌고 하위 계층에 있던 구현이 `상위 인터페이스를 의존하므로 최종적으로 `쌍방`으로 의존관계가 `역전`된다.

- 헥사고날 아키텍처 도메인과 유스케이스 -> 비즈니스 계층
    - 헥사고날 아키텍처에서 말하는 도메인과 유스케이스 관계의 핵심은 비즈니스 로직이 도메인에 존재해야한다는 점이다.
    - 도메인 엔티티는 상태를 가지고 있고, 비즈니스 로직상 상태에 변경이 일어난다면 이 변경의 책임은 도메인이 지어야한다는 의미이다. 

- 주도하는(Drving) 어댑터와 주도되는(Driven) 어댑터 / 포트
    - 유스케이스와 엔티티를 이해했다면 어댑터와 포트차례이다. 유스케이스의 의존성 화살표 방향을 보면 Input Port 에는 구현을, Output Port 에는 의존관계를 맺고 있음을 확인할 수 있다.
    - 유스케이스에 Input 되는 포트와 어댑터를 주도하는 어댑터/포트, 혹은 Incomming Adapter/Port 라고 칭하며 유스케이스에 OutPut되는 포트와 어댑터를 어댑터/포트 혹은 Outgoing Adapter/Port 라고 부른다. 

>> 결국 하려는 말은 비즈니스로직이 아무런 의존성을 갖지 않는 도메인에 집중되어 모든 기술적인 코드를 분리하는 것이 목적이다.

